# Pixi UI 布局经验（按内容自适应）

## 目标
- **在设计分辨率 750×1334 上做 UI 布局**，并在不同屏幕上保持视觉一致。
- **弹窗等容器高度随内容自适应**，避免固定高度造成大面积空白。
- **按钮/文本等组件宽度随内容与容器约束自适应**，避免"写死尺寸"。

## 推荐的组织方式
- **init 只做一次性创建**：创建 `Container`、`Graphics`、`Text`、按钮等显示对象，并加入层级。
- **show/update 只改数据**：更新文案、分数、显隐状态、按钮组合等。
- **layout 专门做布局**：所有位置与尺寸计算集中在一个布局函数中（例如 `_layoutModal()`），在每次内容变化后调用。
- **draw 专门画背景**：背景绘制集中在 `_drawXXXBackground()`，由 layout 决定最终宽高后触发重绘。

## 弹窗（Modal）自适应高度的做法
- **避免固定高度**：高度应由内容高度与间距累加得到。
- **以内容计算高度**：建议按"标题行 / 得分行 / 提示文案 / 按钮行"的实际高度计算：
  - 先读取各行的 `Text.height`（必要时根据显隐决定是否计入）。
  - 按固定的 padding 与 gap 累加出 `totalHeight`。
  - 将 `modalHeight = ceil(totalHeight)` 作为最终高度。
- **重绘背景**：当高度变化时，先更新 `this.height`，再调用背景绘制方法重画圆角矩形。
- **重新摆放子元素**：布局应以容器中心为原点，从顶部 padding 开始逐行向下摆放：
  - `y = -height/2 + paddingTop`
  - 每行中心点 `centerY = y + rowHeight/2`
  - 行结束 `y += rowHeight`，行间距再额外累加。

## 一行得分的居中布局
- 目标是实现类似"本关得分：605"的**同一行居中**。
- 做法：把"标签"和"数值"作为一行的两个 `Text`，根据两者宽度求总宽：
  - `rowWidth = label.width + gap + value.width`
  - 从 `startX = -rowWidth/2` 起放置 label 与 value，使整行在容器中居中。
- 注意：`Text.width` 依赖当前 `text/style`，必须在设置 `text` 后再做布局。

## 两个按钮并排且宽度自适应
- **不要写死按钮宽度**：按钮宽度应同时考虑：
  - 文案长度（最小可读宽度）
  - 容器可用宽度（不能溢出弹窗）
  - 视觉一致性（两个按钮并排时间距固定）
- 推荐策略：
  - 先按"文字宽度 + 内边距"计算每个按钮的理想宽度。
  - 约束到 
    - `minWidth`：保证短文案按钮不会过窄
    - `maxWidth`：避免按钮看起来像整行按钮
  - 如果 `leftW + rightW + gap > maxRowWidth`，则降级为等分：
    - `each = floor((maxRowWidth - gap)/2)`
    - 两按钮都用 `each`。
- 布局时按左右按钮真实宽度居中：
  - `rowW = leftW + rightW + gap`
  - `left.x = -rowW/2 + leftW/2`
  - `right.x = rowW/2 - rightW/2`

## Pixi 绘制与清理的坑
- **`Graphics.clear()` 只清空当前 `Graphics` 的绘制指令**，不会自动清理其 `children`。
  - 如果把装饰条/渐变等作为子节点 `addChild()` 每次重绘都创建新对象，会导致子节点不断累积。
  - 推荐：装饰条直接用同一个 `Graphics` 在 `_drawModalBackground()` 中绘制，或在重绘前显式移除旧子节点。

## 内容切换的显隐策略
- 不同状态（成功/失败/最后一关）内容不同，建议通过 **visible 控制是否参与布局**：
  - 失败态不显示得分行：`scoreContainer.visible = false`
  - 最后一关只显示一个按钮：只创建一个按钮并让其居中
- **布局函数必须基于 visible 计算**，否则会留下空白。

## 动画与布局的顺序
- 先更新内容 → 调用 layout 得到最终尺寸与位置 → 再做入场动画（alpha/scale）。
- 避免动画过程中反复改变尺寸（会引起跳动）。

## 快速自检清单
- **文本更新后是否重新 layout**（特别是分数变化）
- **背景尺寸是否来自 layout 计算结果**
- **重绘背景是否会累积子节点**
- **两按钮并排是否在窄屏/长文案时仍不溢出**
- **不同状态（成功/失败/最后一关）是否无多余空白**
